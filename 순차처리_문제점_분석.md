# 순차 처리 vs 전수조사 비교 분석

## 문제 시나리오

### 예시 데이터
- **항목 1**: A, B, C
- **항목 2**: B, C, D, E (더 큰 집합)
- **항목 3**: A, B, C (항목 1과 완전 동일)

---

## 현재 방식 (순차 처리)

### 처리 순서
1. **항목 1 처리**
   - `deduplicated_entries = []` (비어있음)
   - 비교할 항목 없음 → 추가
   - 결과: `deduplicated_entries = [항목 1]`

2. **항목 2 처리**
   - `deduplicated_entries = [항목 1]`
   - 항목 2 vs 항목 1 비교:
     - 교집합: B, C
     - 작은 집합: 항목 1 (3개) < 항목 2 (4개)
     - 규칙 2, 3 적용 → 항목 1 제거
   - 결과: `deduplicated_entries = [항목 2]`

3. **항목 3 처리**
   - `deduplicated_entries = [항목 2]`
   - 항목 3 vs 항목 2 비교:
     - 완전 동일 아님
     - 교집합: B, C
     - 작은 집합: 항목 3 (3개) < 항목 2 (4개)
     - 규칙 2, 3 적용 → 항목 3 제거
   - 결과: `deduplicated_entries = [항목 2]`

**최종 결과**: 항목 2만 남음 ✅

---

## 다른 시나리오

### 예시 데이터 (순서 변경)
- **항목 1**: B, C, D, E (더 큰 집합)
- **항목 2**: A, B, C
- **항목 3**: A, B, C (항목 2와 완전 동일)

### 처리 순서
1. **항목 1 처리**
   - 비교할 항목 없음 → 추가
   - 결과: `deduplicated_entries = [항목 1]`

2. **항목 2 처리**
   - 항목 2 vs 항목 1 비교:
     - 교집합: B, C
     - 작은 집합: 항목 2 (3개) < 항목 1 (4개)
     - 규칙 2, 3 적용 → 항목 2 제거
   - 결과: `deduplicated_entries = [항목 1]`

3. **항목 3 처리**
   - 항목 3 vs 항목 1 비교:
     - 교집합: B, C
     - 작은 집합: 항목 3 (3개) < 항목 1 (4개)
     - 규칙 2, 3 적용 → 항목 3 제거
   - 결과: `deduplicated_entries = [항목 1]`

**최종 결과**: 항목 1만 남음 ✅

---

## 전수조사 방식

### 모든 항목 비교
1. **항목 1 vs 항목 2**
   - 교집합: B, C
   - 작은 집합: 항목 1 제거

2. **항목 1 vs 항목 3**
   - 완전 동일 → 항목 3 제거

3. **항목 2 vs 항목 3**
   - 완전 동일 → 항목 3 제거

**최종 결과**: 항목 2만 남음 (또는 항목 1만 남음, 순서에 따라)

---

## 문제점 분석

### 1. 순서 의존성
- 현재 방식은 입력 순서에 따라 결과가 달라질 수 있음
- 하지만 위 예시에서는 두 경우 모두 올바른 결과가 나옴

### 2. 완전 동일 항목 처리
- 현재 방식은 완전 동일한 항목을 잘 처리함
- `_are_identical_quote_sets()`로 먼저 체크

### 3. 교집합 처리
- 교집합이 있을 때 작은 집합을 제거하는 것은 올바름
- 하지만 저장된 항목들 간의 비교가 없음

---

## 실제 문제가 발생하는 경우

### 시나리오
- **항목 1**: A, B
- **항목 2**: B, C
- **항목 3**: A, C

### 현재 방식
1. 항목 1 추가 → `[항목 1]`
2. 항목 2 vs 항목 1:
   - 교집합: B
   - 작은 집합: 항목 1 (2개) = 항목 2 (2개)
   - 크기가 같으면 현재 집합 제거 → 항목 2 제거
   - 결과: `[항목 1]`
3. 항목 3 vs 항목 1:
   - 교집합: A
   - 작은 집합: 항목 1 (2개) = 항목 3 (2개)
   - 크기가 같으면 현재 집합 제거 → 항목 3 제거
   - 결과: `[항목 1]`

### 전수조사
- 항목 1 vs 항목 2: 교집합 B → 작은 집합 제거 (크기 같으면 항목 1 제거)
- 항목 1 vs 항목 3: 교집합 A → 작은 집합 제거 (크기 같으면 항목 1 제거)
- 항목 2 vs 항목 3: 교집합 없음 → 둘 다 유지

**결과 차이**: 전수조사는 항목 2와 항목 3이 모두 남을 수 있음

---

## 해결 방안

### 옵션 1: 저장된 항목들 간에도 비교 수행
- 현재 항목을 추가하기 전에 저장된 항목들 간 비교
- 메모리와 시간 복잡도 증가

### 옵션 2: 여러 패스로 처리
- 첫 번째 패스: 완전 동일 항목 제거
- 두 번째 패스: 교집합/부분집합 처리
- 시간 복잡도 증가

### 옵션 3: 전수조사 방식 (모든 집합 미리 구하기)
- 모든 항목을 먼저 수집
- 모든 항목 간 비교
- 메모리 사용량 증가

### 옵션 4: 현재 방식 유지 + 후처리
- 현재 방식으로 처리
- 마지막에 저장된 항목들 간 한 번 더 비교
- 추가 시간 소요

---

## 권장 사항

현재 방식이 대부분의 경우 올바른 결과를 제공하지만, 완벽한 전수조사와는 다를 수 있습니다.

**선택지**:
1. **현재 방식 유지**: 대부분의 경우 올바른 결과, 효율적
2. **전수조사 방식**: 정확하지만 리소스 많이 사용
3. **하이브리드**: 현재 방식 + 저장된 항목들 간 추가 비교


